using UAssetAPI.UnrealTypes;
using UAssetAPI;
using UAssetAPI.Unversioned;


class MyProcess {
    static EngineVersion engineVersion = EngineVersion.VER_UE5_3;
    // Update these path values to match your own machine
    static Usmap mappings = new Usmap("D:\\Modding\\MarvelRivals\\mappings\\5.3.2-1525091+++depot_marvel+S1_1_release-Marvel.usmap");
    static string inputPathPrefix = "D:\\Modding\\MarvelRivals\\repos\\UAssetMaterialProcessing\\UAssetMaterialProcessing\\uassets\\";
    static string fileSuffix = ".uasset";

    static void Main(string[] args) {

        ModifyAndWrite(SampleTargetGenerator_Basic());
        ModifyAndWrite(SampleTargetGenerator_Advanced());
        //ModifyAndWrite(MagikMaterialTargetsGenerator());
    }

    private static void ModifyAndWrite(List<FileTarget> fileTargets) {
        foreach (FileTarget target in fileTargets) {
            UAsset myAsset = new UAsset($"{inputPathPrefix}{target.localPathPrefix}{target.name}{fileSuffix}", engineVersion, mappings);
            myAsset = MaterialProcessing.ModifyTargets(
                myAsset,
                target.scalarTargets,
                target.vectorTargets,
                printOutput: true,
                printFilename: target.name
            );
            myAsset.Write($"edited\\{target.localPathPrefix}{target.name}{fileSuffix}");

        }
    }
    struct FileTarget {
        public string localPathPrefix;
        public string name;
        public List<Tuple<Func<string, bool>, Func<float, float>>>? scalarTargets;
        public List<Tuple<Func<string, bool>, Func<float[], float[]>>>? vectorTargets;

        public FileTarget(string localPathPrefix, string name) {
            this.localPathPrefix = localPathPrefix;
            this.name = name;
        }

        public void AddScalarTarget(Func<string, bool> targetFunc, Func<float, float> modifyFunc) {
            if (this.scalarTargets == null) {
                this.scalarTargets = new List<Tuple<Func<string, bool>, Func<float, float>>>();
            }
            this.scalarTargets.Add(new(targetFunc, modifyFunc));
        }

        public void AddVectorTarget(Func<string, bool> targetFunc, Func<float[], float[]> modifyFunc) {
            if (this.vectorTargets == null) {
                this.vectorTargets = new List<Tuple<Func<string, bool>, Func<float[], float[]>>>();
            }
            this.vectorTargets.Add(new(targetFunc, modifyFunc));
        }
    }

    private static List<FileTarget> SampleTargetGenerator_Basic() {
        List<FileTarget> fileTargets = new List<FileTarget>();

        // Initialize a FileTarget by supplying the path (leading up to the name), and the name itself.
        // The name is appended onto the path so the divide is arbitrary; it's just separated so console output can be less cluttered.
        string magikVfxLocalPathPrefix = "Marvel\\VFX\\Materials\\Characters\\1029\\Materials\\";
        string magikSampleVfxFilename = "MI_1029500_Flow_26_001";
        FileTarget sampleFileTarget = new FileTarget(magikVfxLocalPathPrefix, magikSampleVfxFilename);

        // Supply a scalar/vector target conditional function, and a modification function to go with it.

        // So usually we want to target vectors containing the word "Color".
        // This is a lambda function which takes a parameter name (which will be supplied from the vector's ParameterInfo).
        // You want the function to return true if the given name is one that you want to target.
        Func<string, bool> sampleVectorTargetFunc = name => name.ToLower().Contains("color");

        // Now we define the function which will perform an operation on the targeted vector's value. 
        // This one will just divide each RGB channel by 2.
        Func<float[], float[]> sampleVectorModifyFunc = value => [value[0] / 2f, value[1] / 2f, value[2] / 2f];

        // Now add the two functions to the filetarget (they're stored together as a tuple)
        sampleFileTarget.AddVectorTarget(sampleVectorTargetFunc, sampleVectorModifyFunc);

        // Don't forget to add your new fileTarget to the List.
        fileTargets.Add(sampleFileTarget);

        // That's it! You can pass the list generated by this function to ModifyAndWrite() in the main method.
        // It'll find the corresponding file, locate vectors which succeed the targeting function, and perform the modification on their value.
        // Use whatever logic you need to generate this list; see MagikMaterials() for a big ugly example I use to generate changes for Magik.
        // Though first look at SampleTargetGenerator_Advanced() for some slightly more in-depth concepts.

        return fileTargets;
    }

    private static List<FileTarget> SampleTargetGenerator_Advanced() {
        List<FileTarget> fileTargets = new List<FileTarget>();

        // Here I'll show some slightly more advanced topics. 

        string magikCharLocalPathPrefix = "Marvel\\Characters\\1029\\1029500\\Materials\\10290\\Lobby\\";
        string magikCharSampleFilePrefix = "MI_1029500_10290_";

        // This file is the material for Magik's Eldritch Armor's crown
        FileTarget crownMaterial = new FileTarget(magikCharLocalPathPrefix, magikCharSampleFilePrefix + "Equip_04");

        // We can add a scalar target the same way we do vector ones.
        // This simply sets the value of cubeMapStrength to 5.
        crownMaterial.AddScalarTarget(name => name == "cubeMapStrength", value => 5);

        // (now back to vectors)
        // Earlier we just targeted all vectors with "Color" in the name. We can do that while also including more specific targets.
        // IMPORTANT: The targeting function that succeeds FIRST will be used; therefore make sure to include more-specific targets before more-general ones!
        
        // So first, we'll define a modification that sets a specific vector to a specific value.
        crownMaterial.AddVectorTarget(name => name == "BasicLineColor", value => [1, 0.8f, 0.5f]);

        // Then, we'll define a more general modification.
        // BasicLineColor should end up using the above modification, while everything else should use the below one.
        crownMaterial.AddVectorTarget(name => name.ToLower().Contains("color"), value => [value[0] / 2f, value[1] / 2f, value[2] / 2f]);

        fileTargets.Add(crownMaterial);

        // Since we'll probably mostly be editing colors, I wrote some methods for working with colors.
        // They're in the "MarvelRivals" file/namespace, in the class ColorOps.

        // First I'll show an example of a basic modification.
        // This is the material for Magik's Eldritch Armor's chest gem.
        FileTarget chestgemMaterial = new FileTarget(magikCharLocalPathPrefix, magikCharSampleFilePrefix + "Equip_05");
        // We'll target colors like usual...
        Func<string, bool> targetColorsFunc = name => name.ToLower().Contains("color");

        // This'll use my function ModifyHSL. It makes it easier to edit an RGB color in a practical manner by converting it to HSL color.
        // HSL = Hue, Saturation, Lightness. I'd recommend using an online HSL color picker to better understand it.
        //      Hue is the color from 0 to 359, where 0 is red, 120 is green, 240 is blue, and at 360 it wraps back around to 0 (red).
        //      Saturation is how strong the hue shows up from white; 0 is pure white/gray, while 255 is pure color (scaling to black if lightness is 0).
        //      Lightness is how strong the hue shows up from black; 0 is pure black, while 255 is pure color (scaling to white if saturation is 0).
        // So for ModifyHSL, you first pass in the rgb float[], then any H, S, and/or L functions you want to perform on it. 
        // (Be aware of the range of each data type!! rgb float[] channels go from 0f to 1f, H is an int from 0 to 359, and S & L are bytes from 0 to 255)
        // Here we'll just pass in a function which sets the hue to 0 (red).
        // (btw, the parameter name in the arrow function doesn't matter; "rgb" is probably more descriptive than "value")
        Func<float[], float[]> setHueRedFunc = rgb => ColorOps.ModifyHSL(rgb, ModifyH: hue => 0);

        // However, there's a problem with just calling this ModifyHSL function; it clamps the value of each rgb channel to [0, 1].
        // Meanwhile, many color channel values in this game go above 1; this is crucial for things like bright flame effects.
        // So, you'll want to wrap calls of ModifyHSL inside the succinctly-named function NormalizeThenFunctionThenUnnormalize().
        // So if the original rgb was [0, 5, 10], this'll change it to [10, 0, 0] (pure red with max intensity of 10 restored).
        Func<float[], float[]> normalizedSetHueRedFunc = rgb => ColorOps.NormalizeThenFunctionThenUnnormalize(rgb, setHueRedFunc);
        chestgemMaterial.AddVectorTarget(targetColorsFunc, normalizedSetHueRedFunc);
        fileTargets.Add(chestgemMaterial);

        // I've also written a more specific hue modification function which I used for transforming gradients.
        // Basically, Magik's Eldritch Armor flames have a blue -> cyan gradient; I wanted to remap this gradient to red -> yellow.
        // So I have a function that takes a source gradient (eg. blue -> cyan), a target gradient (eg. red -> yellow), and a hue which (theoretically)
        //  is somewhere on the source gradient (eg. sky blue), and then it maps it to the equivalent position on the target gradient (eg. orange).
        // Note that hues outside the source gradient will get clamped to its nearest edge; eg. purple would get clamped to blue, which becomes red.

        // I'll show an example on one of the flames on Magik's Eldritch armor:
        string magikVfxLocalPathPrefix = "Marvel\\VFX\\Materials\\Characters\\1029\\Materials\\";
        string magikSampleVfxFilename = "MI_1029500_Flow_26_001";
        FileTarget flowMaterial = new FileTarget(magikVfxLocalPathPrefix, magikSampleVfxFilename);

        Func<int, int> hueMapper_BlueCyan_to_RedYellow =
            hue => ColorOps.MapHueToGradient(
                240, // blue
                180, // cyan
                false, // "negative" direction in the spectrum
                0, // red
                60, // yellow
                true, // "positive" direction in the spectrum
                hue // hue to map from source to target; eg. 210 will become 30
            );
        // Now we need to pass this hueMapper to ModifyHSL to modify an actual rgb value and not just a hue...
        Func<float[], float[]> hslMapper_BlueCyan_to_RedYellow = rgb => ColorOps.ModifyHSL(rgb, ModifyH: hueMapper_BlueCyan_to_RedYellow);
        // Now, as before, we need to account for high-intensity values by wrapping it in the normalization function
        Func<float[], float[]> preserveIntensityColorMapper_BlueCyan_to_RedYellow = unnormalized_rgb => ColorOps.NormalizeThenFunctionThenUnnormalize(unnormalized_rgb, hslMapper_BlueCyan_to_RedYellow);

        flowMaterial.AddVectorTarget(targetColorsFunc, preserveIntensityColorMapper_BlueCyan_to_RedYellow);
        fileTargets.Add(flowMaterial);


        return fileTargets;
    }

    /// <summary>
    /// Turns pretty much all the blue effects for Magik's Eldritch Armor to red
    /// </summary>
    /// <returns></returns>
    private static List<FileTarget> MagikMaterialTargetsGenerator() {
        List<FileTarget> fileTargets = new List<FileTarget>();

        string vfxMatPrefix = "Marvel\\VFX\\Materials\\Characters\\1029\\Materials\\";
        string charMatPrefix = "Marvel\\Characters\\1029\\1029500\\Materials\\";
        string filePrefix = "MI_1029500_";

        Func<string, bool> colorTargeter = name => name.ToLower().Contains("color");

        Func<float[], float[]> blueCyanToRedGoldMapper = rgb => ColorOps.NormalizeThenFunctionThenUnnormalize(
            rgb, normalizedRGB => ColorOps.ModifyHSL(normalizedRGB,
                ModifyH: hue => ColorOps.MapHueToGradient(
                    210, 180, false,
                    0, 55, true,
                    hue)));

        Func<float[], float[]> redMapper = rgb => ColorOps.NormalizeThenFunctionThenUnnormalize(
            rgb, normalizedRGB => ColorOps.ModifyHSL(normalizedRGB,
                ModifyH: _hue => 0));

        // Add vfx "flow" materials
        int flowMax = 62;
        //int flowMax = 1;
        List<int> flowSkip = new List<int>
        {
            8, 23, 24, 26, 29, 58, 59
        };
        for (int i = 1; i <= flowMax; i++) {
            if (flowSkip.Contains(i)) continue;

            string fileNameEnding = "Flow_26_0";
            if (i < 10) fileNameEnding += "0";
            fileNameEnding += i.ToString();

            FileTarget fileTarget = new FileTarget(vfxMatPrefix + filePrefix, fileNameEnding);
            Func<string, bool> generalVectorTargetFunc = colorTargeter;
            Func<float[], float[]> generalVectorModifyFunc;

            if (i == 7 || i == 27 || i == 43) {
                // shoulder outer x (human lobby, human ingame, and darkchylde)
                if (i == 7) {
                    // Add this target first to override BaseColor
                    fileTarget.AddVectorTarget(name => name == "BaseColor", _ => [4, 0, 0]);
                }
                generalVectorModifyFunc = redMapper;
            } else {
                generalVectorModifyFunc = blueCyanToRedGoldMapper;
            }
            fileTarget.AddVectorTarget(generalVectorTargetFunc, generalVectorModifyFunc);
            fileTargets.Add(fileTarget);
        }
        // Add miscellaneous fire materials (not sure exactly what they're for)
        foreach (string endingNum in new string[] { "319", "320", "323", "324", "341", "342" }) {
            FileTarget fileTarget = new FileTarget(vfxMatPrefix + "MI_", "Fire_13_" + endingNum);
            fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
            fileTargets.Add(fileTarget);
        }
        // Add character materials to fileItems
        foreach (string innerInnerPath in new string[] { "10290\\", "10290\\Lobby\\" }) {
            // Crown, chest gem, hilt, blade
            foreach (string fileName in new string[] { "Equip_04", "Equip_05", "Weapon_01", "Weapon_02" }) {
                FileTarget fileTarget = new FileTarget(charMatPrefix + innerInnerPath + filePrefix, "10290_" + fileName);
                if (fileName == "Equip_04" || fileName == "Equip_05") {
                    // Overrides for crown and chest gem
                    fileTarget.AddScalarTarget(name => name == "cubeMapStrength", _ => 5);
                    fileTarget.AddVectorTarget(name => name == "BasicLineColor", _ => [0.5f, 0, 0]);
                    fileTarget.AddVectorTarget(name => name == "RampColor1", _ => [1, 0, 0]);
                    fileTarget.AddVectorTarget(name => name == "InnerColor", _ => [75, 25, 0]);
                    fileTarget.AddVectorTarget(name => name == "RimLightColor", _ => [0.7f, 0.1f, 0]);
                    fileTarget.AddVectorTarget(name => name == "LineSpecColor", _ => [0.8f, 0, 0]);
                }
                fileTarget.AddVectorTarget(colorTargeter, redMapper);
                fileTargets.Add(fileTarget);
            }
        }
        // Lobby weapon effects
        foreach (string fileName in new string[] { "Weapon_02_FX_01", "Weapon_02_FX_02" }) {
            FileTarget fileTarget = new FileTarget(charMatPrefix + "10290\\Lobby\\" + filePrefix, "10290_" + fileName);
            fileTarget.AddVectorTarget(colorTargeter, redMapper);
            fileTargets.Add(fileTarget);
        }

        // Add Darkchylde materials
        foreach (string innerInnerPath in new string[] { "10291\\", "10291\\Lobby\\" }) {
            // Blade, Eyes, Hair
            foreach (string fileName in new string[] { "Weapon_02", "Eyes_01", "Hair_03" }) {
                FileTarget fileTarget = new FileTarget(charMatPrefix + innerInnerPath + filePrefix, "10291_" + fileName);
                if (fileName == "Weapon_02") {
                    // Overrides for sword blade
                    fileTarget.AddScalarTarget(name => name == "cubeMapStrength", _ => 4);
                    fileTarget.AddVectorTarget(name => name == "BasicLineColor", _ => [1, 0, 0]);
                    fileTarget.AddVectorTarget(name => name == "RampColor1", _ => [0, 0, 0]);
                    fileTarget.AddVectorTarget(name => name == "InnerColor", _ => [0, 0, 0]);
                    fileTarget.AddVectorTarget(name => name == "RimLightColor", _ => [1, 0, 0]);
                    fileTarget.AddVectorTarget(name => name == "LineSpecColor", _ => [0, 0, 0]);
                }
                fileTarget.AddVectorTarget(colorTargeter, redMapper);
                fileTargets.Add(fileTarget);
            }
        }

        // Add MVP materials
        string mvpFilePrefix = "MI_MVP_";
        foreach (string mvpNamePrefix in new string[] { "BackScreen_13_", "FadeOneMins_13_", "Fire_13_", "Flash_13_", "FreezeFire_13_", "Knife_13_", "Portal_13_", "Ring_13_", "Spark_13_", "Trail_13_", "Wind_13_" }) {
            if (mvpNamePrefix == "BackScreen_13_") {
                FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + "301");
                fileTarget.AddVectorTarget(colorTargeter, redMapper);
                fileTargets.Add(fileTarget);
            } else if (mvpNamePrefix == "FadeOneMins_13_") {
                FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + "301");
                fileTarget.AddVectorTarget(colorTargeter, redMapper);
                fileTargets.Add(fileTarget);
            } else if (mvpNamePrefix == "Fire_13_") {
                for (int i = 318; i <= 329; i++) {
                    if (i == 329) {
                        // skip from 328 to 339
                        i = 339;
                        continue;
                    }
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + i.ToString());
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            } else if (mvpNamePrefix == "Flash_13_") {
                foreach (string num in new string[] { "301", "302" }) {
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + num);
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            } else if (mvpNamePrefix == "FreezeFire_13_") {
                foreach (string num in new string[] { "301", "302", "303" }) {
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + num);
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            } else if (mvpNamePrefix == "Knife_13_") {
                FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + "306");
                fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                fileTargets.Add(fileTarget);
            } else if (mvpNamePrefix == "Portal_13_") {
                foreach (string num in new string[] { "302", "303", "304" }) {
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + num);
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            } else if (mvpNamePrefix == "Ring_13_") {
                foreach (string num in new string[] { "301", "302" }) {
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + num);
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            } else if (mvpNamePrefix == "Trail_13_") {
                for (int i = 301; i <= 313; i++) {
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + i.ToString());
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            } else if (mvpNamePrefix == "Wind_13_") {
                foreach (string num in new string[] { "301", "302", "303", "306", "307" }) {
                    FileTarget fileTarget = new FileTarget(vfxMatPrefix, mvpFilePrefix + mvpNamePrefix + num);
                    fileTarget.AddVectorTarget(colorTargeter, blueCyanToRedGoldMapper);
                    fileTargets.Add(fileTarget);
                }
            }
        }

        // Magik Slash?

        Func<float[], float[]> trajectoryMapper = rgb => ColorOps.NormalizeThenFunctionThenUnnormalize(
            rgb, normalizedRGB => ColorOps.ModifyHSL(normalizedRGB,
                ModifyH: hue => ColorOps.MapHueToGradient(
                    30, 53, true,
                    0, 53, true,
                    hue)));

        foreach (string num in new string[] { "08", "09", "10", "11" }) {
            FileTarget fileTarget = new FileTarget(vfxMatPrefix + "MI_", "Trajectory_1_001_" + num);
            fileTarget.AddVectorTarget(colorTargeter, trajectoryMapper);
            fileTargets.Add(fileTarget);
        }

        return fileTargets;
    }
}
